//!
//! # Rust å¼‚æ­¥é€’å½’ç¤ºä¾‹é¡¹ç›®
//!
//! æœ¬é¡¹ç›®æ¼”ç¤ºäº† Rust ä¸­å¼‚æ­¥é€’å½’å‡½æ•°çš„å®ç°æ–¹æ³•ï¼Œä»¥åŠç›¸å…³çš„é«˜çº§å¼‚æ­¥ç¼–ç¨‹æ¦‚å¿µã€‚
//!
//! ## å­¦ä¹ ç›®æ ‡
//! - ç†è§£å¼‚æ­¥é€’å½’å‡½æ•°çš„å·¥ä½œåŸç†
//! - æŒæ¡ `async-recursion` åº“çš„ä½¿ç”¨
//! - å­¦ä¹  `Pin<Box<dyn Future>>` çš„ä½¿ç”¨æ–¹æ³•
//! - äº†è§£ Tokio è¿è¡Œæ—¶çš„åŸºæœ¬æ¦‚å¿µ
//!
//! ## é‡è¦æ¦‚å¿µ
//!
//! ### å¼‚æ­¥é€’å½’ (Async Recursion)
//! åœ¨å¼‚æ­¥ç¼–ç¨‹ä¸­ï¼Œé€’å½’å‡½æ•°éœ€è¦ç‰¹æ®Šçš„å¤„ç†ï¼Œå› ä¸ºæ™®é€šçš„é€’å½’å‡½æ•°åœ¨ç¼–è¯‘æ—¶æ— æ³•ç¡®å®šå…¶å¤§å°ã€‚
//! `async-recursion` åº“é€šè¿‡å®æ¥è‡ªåŠ¨å¤„ç†è¿™ä¸ªé™åˆ¶ã€‚
//!
//! ### Future å’Œ Pin
//! - `Future`: Rust å¼‚æ­¥ç¼–ç¨‹çš„æ ¸å¿ƒ traitï¼Œè¡¨ç¤ºä¸€ä¸ªå¯èƒ½åœ¨æœªæ¥å®Œæˆçš„å€¼
//! - `Pin`: ç¡®ä¿æ•°æ®åœ¨å†…å­˜ä¸­çš„ä½ç½®ä¸ä¼šæ”¹å˜ï¼Œè¿™å¯¹äºè‡ªå¼•ç”¨ç±»å‹éå¸¸é‡è¦
//! - `Box<dyn Future>`: åŠ¨æ€åˆ†å‘ Future ç±»å‹ï¼Œå…è®¸åœ¨è¿è¡Œæ—¶é€‰æ‹©ä¸åŒçš„å¼‚æ­¥æ“ä½œ
//!
//! ## ç›¸å…³æ–‡æ¡£é“¾æ¥
//! - [Rust å¼‚æ­¥ç¼–ç¨‹æŒ‡å—](https://rust-lang.github.io/async-book/)
//! - [Tokio å®˜æ–¹æ–‡æ¡£](https://tokio.rs/tokio/tutorial)
//! - [async-recursion crate æ–‡æ¡£](https://docs.rs/async-recursion/latest/async_recursion/)
//! - [Future trait æ–‡æ¡£](https://doc.rust-lang.org/std/future/trait.Future.html)
//! - [Pin ç±»å‹æ–‡æ¡£](https://doc.rust-lang.org/std/pin/struct.Pin.html)

use async_recursion::*;
use std::pin::Pin;

// å¯¼å…¥ Pin ç¤ºä¾‹æ¨¡å—
mod pin_examples;
use pin_examples::*;

/// ä½¿ç”¨å¼‚æ­¥é€’å½’å®ç°çš„æ–æ³¢é‚£å¥‘æ•°åˆ—
///
/// # å‚æ•°
/// * `n` - è¦è®¡ç®—çš„æ–æ³¢é‚£å¥‘æ•°åˆ—ä½ç½®
///
/// # è¿”å›å€¼
/// æ–æ³¢é‚£å¥‘æ•°åˆ—ç¬¬ n é¡¹çš„å€¼
///
/// # ç¤ºä¾‹
/// ```rust
/// let result = fibonacci(10).await;
/// println!("{}", result); // è¾“å‡º 89
/// ```
///
/// # æ³¨æ„äº‹é¡¹
/// - è¿™æ˜¯ä¸€ä¸ªæ•™å­¦ç¤ºä¾‹ï¼Œå®é™…åº”ç”¨ä¸­æ•ˆç‡è¾ƒä½
/// - å¤§æ•°å€¼è®¡ç®—æ—¶å»ºè®®ä½¿ç”¨åŠ¨æ€è§„åˆ’æˆ–è¿­ä»£æ–¹æ³•
/// - æ¼”ç¤ºäº† `async-recursion` å®çš„åŸºæœ¬ç”¨æ³•
///
/// # ç›¸å…³ç®—æ³•
/// - æ—¶é—´å¤æ‚åº¦: O(2^n) - æŒ‡æ•°çº§ï¼Œé€‚åˆæ•™å­¦ä½†ä¸é€‚åˆç”Ÿäº§ç¯å¢ƒ
/// - ç©ºé—´å¤æ‚åº¦: O(n) - é€’å½’è°ƒç”¨æ ˆæ·±åº¦
///
/// # å­¦ä¹ èµ„æº
/// - [æ–æ³¢é‚£å¥‘æ•°åˆ—ç»´åŸºç™¾ç§‘](https://zh.wikipedia.org/wiki/æ–æ³¢é‚£å¥‘æ•°åˆ—)
/// - [é€’å½’ç®—æ³•æ•™ç¨‹](https://www.runoob.com/data-structures/data-structures-tutorial-recursion.html)
#[async_recursion]
async fn fibonacci(n: u32) -> u32 {
    match n {
        // åŸºç¡€æƒ…å†µï¼šfibonacci(0) = 1
        0 => 1,
        // åŸºç¡€æƒ…å†µï¼šfibonacci(1) = 1
        1 => 1,
        // é€’å½’æƒ…å†µï¼šfibonacci(n) = fibonacci(n-1) + fibonacci(n-2)
        _ => fibonacci(n - 1).await + fibonacci(n - 2).await,
    }
}

/// ç®€å•çš„å¼‚æ­¥å‡½æ•° - æ‰“å° "one"
///
/// è¿™æ˜¯ä¸€ä¸ªåŸºç¡€å¼‚æ­¥å‡½æ•°ï¼Œç”¨äºæ¼”ç¤ºå¼‚æ­¥å‡½æ•°çš„åŸºæœ¬æ¦‚å¿µ
async fn one() {
    println!("one");
}

/// ç®€å•çš„å¼‚æ­¥å‡½æ•° - æ‰“å° "two"
///
/// å¦ä¸€ä¸ªåŸºç¡€å¼‚æ­¥å‡½æ•°ï¼Œç”¨äºé…åˆ one() å‡½æ•°æ¼”ç¤ºå‡½æ•°é€‰æ‹©
async fn two() {
    println!("two");
}

/// æ ¹æ®è¾“å…¥è°ƒç”¨ä¸åŒçš„å¼‚æ­¥å‡½æ•°
///
/// è¿™ä¸ªå‡½æ•°æ¼”ç¤ºäº†å¦‚ä½•åœ¨è¿è¡Œæ—¶åŠ¨æ€é€‰æ‹©è¦æ‰§è¡Œçš„å¼‚æ­¥å‡½æ•°ï¼Œ
/// å¹¶ç«‹å³æ‰§è¡Œå®ƒã€‚è¿™æ˜¯æ›´å¸¸è§çš„å¼‚æ­¥ç¼–ç¨‹æ¨¡å¼ã€‚
///
/// # å‚æ•°
/// * `n` - é€‰æ‹©è¦è°ƒç”¨çš„å‡½æ•° (1 æˆ– 2)
///
/// # ç¤ºä¾‹
/// ```rust
/// call_one_or_two(1).await; // æ‰“å° "one"
/// call_one_or_two(2).await; // æ‰“å° "two"
/// ```
async fn call_one_or_two(n: u32) {
    match n {
        1 => one().await,    // ç›´æ¥è°ƒç”¨å¹¶ç­‰å¾… one() å‡½æ•°
        2 => two().await,    // ç›´æ¥è°ƒç”¨å¹¶ç­‰å¾… two() å‡½æ•°
        _ => panic!("Invalid choice: must be 1 or 2"),
    }
}

/// è¿”å›è£…ç®± Future çš„ç‰ˆæœ¬ï¼ˆä»…ç”¨äºæ¼”ç¤ºï¼Œä¸æ¨èä½¿ç”¨ï¼‰
///
/// è¿™ä¸ªå‡½æ•°å±•ç¤ºå¦‚ä½•è¿”å› Pin<Box<dyn Future>> ç±»å‹ï¼Œ
/// æ³¨æ„è¿™ä¸ªå‡½æ•°ä¸æ˜¯å¼‚æ­¥çš„ï¼Œç›´æ¥è¿”å›ä¸€ä¸ª Futureã€‚
///
/// # é‡è¦è¯´æ˜
/// è¿™ä¸ªå‡½æ•°è¿”å›çš„ Future ä¸ä¼šè‡ªåŠ¨æ‰§è¡Œï¼è°ƒç”¨è€…éœ€è¦ï¼š
/// ```rust
/// let future = call_one_or_two_boxed(1);
/// tokio::pin!(future);
/// future.await; // æˆ–è€…ä½¿ç”¨å…¶ä»–æ–¹å¼ poll Future
/// ```
fn call_one_or_two_boxed(n: u32) -> Pin<Box<dyn Future<Output = ()>>> {
    match n {
        1 => {
            // å°† one() å‡½æ•°è£…ç®±å¹¶å›ºå®š
            // Box::pin() åˆ›å»ºä¸€ä¸ª Pin<Box<dyn Future>> ç±»å‹
            Box::pin(one())
        },
        2 => {
            // å°† two() å‡½æ•°è£…ç®±å¹¶å›ºå®š
            Box::pin(two())
        },
        _ => panic!("Invalid choice: must be 1 or 2"),
    }
}

/// ç¨‹åºå…¥å£ç‚¹ - æ¼”ç¤ºå¼‚æ­¥é€’å½’å’Œ Future æ“ä½œ
///
/// # æ‰§è¡Œæ­¥éª¤
/// 1. è®¡ç®—å¹¶æ‰“å°æ–æ³¢é‚£å¥‘æ•°åˆ—ç¬¬ 10 é¡¹
/// 2. åˆ›å»ºå¹¶æ‰§è¡Œä¸€ä¸ªç®€å•çš„å¼‚æ­¥å—
/// 3. ä½¿ç”¨ tokio::pin! å®å›ºå®š Future
/// 4. æ¼”ç¤ºåŠ¨æ€å‡½æ•°é€‰æ‹©
///
/// # tokio::main å®è¯´æ˜
/// è¿™ä¸ªå®ä¼šè‡ªåŠ¨åˆ›å»ºä¸€ä¸ª Tokio è¿è¡Œæ—¶ï¼Œå¹¶åœ¨å…¶ä¸­æ‰§è¡Œ async main å‡½æ•°ã€‚
///
/// # tokio::pin! å®è¯´æ˜
/// å°†å˜é‡å›ºå®šåˆ°æ ˆä¸Šï¼Œç¡®ä¿å®ƒåœ¨å†…å­˜ä¸­çš„ä½ç½®ä¸ä¼šæ”¹å˜ã€‚
/// è¿™å¯¹äºè‡ªå¼•ç”¨çš„ Future ç±»å‹æ˜¯å¿…éœ€çš„ã€‚
#[tokio::main]
async fn main() {
    // 1. æ¼”ç¤ºå¼‚æ­¥é€’å½’ï¼šè®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—
    // fibonacci(10) = 89ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„æµ‹è¯•ç”¨ä¾‹
    println!("fibonacci(10): {}", fibonacci(10).await);

    // 2. åˆ›å»ºä¸€ä¸ªç®€å•çš„å¼‚æ­¥å—
    let future = async {
        println!("Hello world");
    };

    // 3. ä½¿ç”¨ tokio::pin! å®å›ºå®š Future
    // è¿™ç¡®ä¿äº† future ä¸ä¼šè¢«ç§»åŠ¨ï¼Œä¿è¯å†…å­˜å®‰å…¨
    tokio::pin!(future);

    // 4. æ‰§è¡Œè¢«å›ºå®šçš„ Future
    // æ³¨æ„ï¼šè¿™é‡Œä½¿ç”¨ &mut futureï¼Œå› ä¸º future è¢« pin! å®æ¶ˆè€—äº†
    (&mut future).await;

    // 5. æ¼”ç¤ºåŠ¨æ€å‡½æ•°é€‰æ‹©
    println!("åŠ¨æ€å‡½æ•°é€‰æ‹©æ¼”ç¤º:");

    // ç›´æ¥è°ƒç”¨å¼‚æ­¥å‡½æ•°è¿›è¡Œå¯¹æ¯”æµ‹è¯•
    println!("ç›´æ¥è°ƒç”¨ one():");
    one().await;

    println!("ç›´æ¥è°ƒç”¨ two():");
    two().await;

    println!("é€šè¿‡åŠ¨æ€é€‰æ‹©è°ƒç”¨ (æ¨èæ–¹å¼):");
    call_one_or_two(1).await; // è°ƒç”¨ one() å‡½æ•°
    call_one_or_two(2).await; // è°ƒç”¨ two() å‡½æ•°

    println!("æ¼”ç¤ºè£…ç®± Future çš„ä½¿ç”¨ (é«˜çº§ç”¨æ³•):");
    println!("è·å–è£…ç®± Future 1...");
    let boxed_future1 = call_one_or_two_boxed(1);
    tokio::pin!(boxed_future1);
    boxed_future1.await;

    println!("è·å–è£…ç®± Future 2...");
    let boxed_future2 = call_one_or_two_boxed(2);
    tokio::pin!(boxed_future2);
    boxed_future2.await;

    println!("å‡½æ•°è°ƒç”¨å®Œæˆ");

    // 6. æ¼”ç¤º Pin ç±»å‹çš„è¯¦ç»†ä½¿ç”¨
    println!();
    println!("{}", "=".repeat(50));
    println!("ğŸ“š å¼€å§‹ Pin ç±»å‹è¯¦ç»†æ¼”ç¤º");
    println!("{}", "=".repeat(50));
    run_all_pin_examples().await;
}
